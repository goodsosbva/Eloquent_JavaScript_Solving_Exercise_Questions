# 순환 종속성 (Circular Dependency)

CommonJS 모듈 시스템에서 순환 종속성이 어떻게 작동하는지 설명하는 예제입니다.

## 📋 개념 설명

### 순환 종속성이란?

모듈 A가 모듈 B를 require하고, 모듈 B가 다시 모듈 A를 require하는 경우를 말합니다.

```
A.js ──require──> B.js
  ↑                │
  └──require───────┘
```

### 대부분의 모듈 시스템

대부분의 모듈 시스템(ES 모듈 등)은 순환 종속성을 **금지**합니다. 이유는:

- 모듈 간 의존성을 실행 전에 결정할 수 없음
- 어떤 모듈을 먼저 로드해야 할지 알 수 없음

### CommonJS의 특별한 경우

CommonJS는 **일정 조건 하에서** 순환 종속성을 허용합니다:

1. ✅ **기본 `exports` 객체를 교체하지 않음**

   - `exports.functionName = ...` 형태로 속성 추가
   - `module.exports = {...}` 형태로 객체 교체하면 문제 발생

2. ✅ **모듈 로딩이 완료된 후 인터페이스 접근**
   - 모듈 최상위 레벨에서 require한 모듈의 함수를 즉시 호출하지 않음
   - 함수 내부에서 나중에 호출

## 📁 파일 구조

### 정상 작동하는 예제

- `a.js` - 모듈 A (모듈 B를 require)
- `b.js` - 모듈 B (모듈 A를 require) - 순환 종속성
- `main.js` - 메인 실행 파일

### 문제가 발생하는 예제

- `a-broken.js` - exports 객체를 교체한 모듈 A
- `b-broken.js` - exports 객체를 교체한 모듈 B
- `main-broken.js` - 문제 상황 테스트

## 🔍 작동 원리

### CommonJS 모듈 로딩 과정

1. **모듈 A 로딩 시작**

   ```javascript
   const b = require("./b.js"); // 모듈 B 로딩 시작
   ```

2. **모듈 B 로딩 시작**

   ```javascript
   const a = require("./a.js"); // 모듈 A는 이미 로딩 중
   ```

   - 이 시점에서 모듈 A는 아직 로딩이 완료되지 않았지만
   - CommonJS는 **부분적으로 로드된 exports 객체**를 반환

3. **exports 객체의 상태**
   - 모듈 A가 로딩 중일 때: `exports` 객체는 빈 객체 `{}`
   - 모듈 A 로딩 완료 후: `exports` 객체에 속성들이 추가됨

### 정상 작동하는 경우

```javascript
// a.js
const b = require("./b.js");

// ✅ exports 객체에 속성 추가 (교체하지 않음)
exports.functionFromA = function () {
  return "함수 A";
};

// ✅ 나중에 사용 (모듈 로딩 완료 후)
function useB() {
  return b.functionFromB(); // 모듈 B 로딩 완료 후 호출
}
```

**작동 이유:**

- `exports` 객체는 참조로 전달됨
- 모듈 로딩 중에 속성을 추가하면, 이미 require한 모듈에서도 접근 가능
- 함수 호출은 모듈 로딩 완료 후에 이루어짐

### 문제가 발생하는 경우

```javascript
// a-broken.js
const b = require("./b.js");

// ❌ exports 객체를 새 객체로 교체
module.exports = {
  functionFromA: function () {
    return "함수 A";
  },
};

// 모듈 B가 이미 require한 exports 객체와는 다른 새 객체
```

**문제점:**

- 모듈 B가 require한 시점의 `exports` 객체와
- 모듈 A가 나중에 교체한 `module.exports` 객체가 **다름**
- 모듈 B는 여전히 이전 빈 객체를 참조
- 결과: `undefined` 또는 에러 발생

## 🚀 실행 방법

### 정상 작동하는 예제

```bash
node main.js
```

**예상 출력:**

```
모듈 B 로딩 시작
모듈 A 로딩 시작
모듈 A 로딩 완료
모듈 B 로딩 완료

=== 순환 종속성 테스트 ===
모듈 A의 함수: 함수 A
모듈 B의 함수: 함수 B

=== 순환 참조 테스트 ===
모듈 A에서 모듈 B의 함수 호출: 함수 B
모듈 B에서 모듈 A의 함수 호출: 함수 A
```

### 문제가 발생하는 예제

```bash
node main-broken.js
```

**예상 출력:**

```
모듈 B 로딩 시작
모듈 A 로딩 시작
모듈 A 로딩 완료
모듈 B 로딩 완료

=== 순환 종속성 문제 테스트 ===
모듈 A의 함수: 함수 A
모듈 B의 함수: 함수 B

=== 순환 참조 테스트 (문제 발생 가능) ===
모듈 A에서 모듈 B의 함수 호출: 함수 B
모듈 B에서 모듈 A의 함수 호출: undefined  ← 문제!
```

## 📝 핵심 포인트

### ✅ 순환 종속성을 안전하게 사용하는 방법

1. **exports 객체에 속성 추가**

   ```javascript
   exports.functionName = function() { ... };
   ```

2. **모듈 로딩 완료 후 접근**

   ```javascript
   // 모듈 최상위 레벨에서 즉시 호출 ❌
   const result = b.functionFromB();

   // 함수 내부에서 나중에 호출 ✅
   function useB() {
     return b.functionFromB();
   }
   ```

### ❌ 피해야 할 패턴

1. **exports 객체 교체**

   ```javascript
   module.exports = { ... };  // 순환 종속성에서 문제 발생
   ```

2. **모듈 로딩 중 즉시 접근**
   ```javascript
   const b = require("./b.js");
   const result = b.functionFromB(); // undefined 가능
   ```

## 🔄 ES 모듈과의 차이

### ES 모듈 (import/export)

- 순환 종속성 **금지**
- 정적 분석으로 의존성 확인
- 더 안전하지만 유연성 낮음

### CommonJS (require/exports)

- 순환 종속성 **조건부 허용**
- 동적 로딩으로 런타임에 의존성 확인
- 유연하지만 주의 필요

## 💡 실무 권장사항

1. **순환 종속성은 피하는 것이 최선**

   - 코드 구조를 재설계하여 순환 제거
   - 공통 모듈로 분리

2. **불가피한 경우**

   - CommonJS에서만 사용
   - exports 객체 교체 금지
   - 모듈 로딩 완료 후 접근

3. **ES 모듈 사용 시**
   - 순환 종속성 자체가 불가능
   - 코드 구조를 명확하게 설계

### 추가\

📌 main 실행 시작
└─ require("./a-broken.js")
▼
🟥 a-broken.js 로딩 시작
└─ (초기) exports = {} (메모리 주소: 0xA1) <-- 기본 exports 객체 생성

    └─ const b = require("./b-broken.js")
          ▼
    🟦 b-broken.js 로딩 시작
    └─ (초기) exports = {}  (메모리 주소: 0xB1)

          └─ const a = require("./a-broken.js")  // 순환 참조 발생 ⚠️
                ▼
          📌 Node 판단:
          "a-broken.js 로딩 중이므로,
           지금까지 작성된 미완성 exports(0xA1) 준다"

          └─ b.js 안에서 a → {}(0xA1)      ⭐ 미완성 A 전달됨

          ▼ 여기서 문제 확정
          module.exports = { functionFromB: ... }  (0xB2 로 새 객체 재할당🔥)
          🟦 b-broken.js 완료
          exports 주소 = 0xB2 로 확정

      ▼ a-broken.js 로 복귀
      현재 b = { functionFromB } (0xB2)

      하지만…
      a.js 자신도 module.exports 를 건드려버림
      ▼

🟥 module.exports = {
functionFromA: ...,
useB: ...
} (0xA2 로 새 객체 재할당🔥)

🟥 a-broken.js 완료
exports 주소 = 0xA2 로 확정

# 더 last 정리리!!

cat << 'EOF'

╔══════════════════════════════════════════════════════════════════════════════╗
║ CommonJS 순환 종속성: 정상 동작 vs 에러 발생 비교 설명 ║
╚══════════════════════════════════════════════════════════════════════════════╝

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1️⃣ ✅ 정상 동작 케이스 (a.js ↔ b.js)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📌 동작 원리:
exports 객체에 속성을 추가하여, 처음 생성된 메모리 주소(0xA1)를
끝까지 유지하고 공유합니다.

📜 코드 특징:
┌─────────────┬──────────────────────────┬────────────────────────────┐
│ 파일 │ 코드 유형 │ 메모리 동작 │
├─────────────┼──────────────────────────┼────────────────────────────┤
│ a.js │ exports.functionFromA │ 기존 객체(0xA1)에 속성 추가 │
│ b.js │ exports.functionFromB │ 기존 객체(0xA1)에 속성 추가 │
└─────────────┴──────────────────────────┴────────────────────────────┘

🔄 순환 참조 시점의 변수 상태:

1.  main → a.js 로딩 시작
    └─> 초기 객체 0xA1 생성

2.  a.js 내부에서 require('b.js') 호출

3.  b.js 내부에서 require('a.js') 호출 (순환 발생!)
    └─> b.js의 const a 변수는 0xA1 객체를 참조합니다.

4.  a.js와 b.js 모두 이 0xA1 객체에 속성만 계속 추가합니다.

🎯 결과: 에러 없음 ✅

b.js 내부의 a 변수가 바라보는 0xA1 객체는 a.js가 완료될 때,
functionFromA 속성도 함께 가지게 됩니다.

A가 B에게 준 객체에 A 자신도 계속 내용을 채워 넣기 때문에,
나중에 B가 그 객체를 사용해도 내용이 온전합니다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2️⃣ ❌ 에러 발생 케이스 (a-broken.js ↔ b-broken.js)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📌 동작 원리:
module.exports를 완전히 새로운 객체로 재할당하여, 순환 참조 시점에
전달된 주소와의 연결이 끊어집니다.

📜 코드 특징:
┌───────────────┬──────────────────────────┬────────────────────────────┐
│ 파일 │ 코드 유형 │ 메모리 동작 │
├───────────────┼──────────────────────────┼────────────────────────────┤
│ a-broken.js │ module.exports = {...} │ 새 객체(0xA2)로 주소 변경 │
│ b-broken.js │ module.exports = {...} │ 새 객체(0xB2)로 주소 변경 │
└───────────────┴──────────────────────────┴────────────────────────────┘

💔 순환 참조 시점의 변수 상태:

1.  main → a-broken.js 로딩 시작
    └─> 초기 객체 0xA1 생성

2.  a-broken.js 내부에서 require('b-broken.js') 호출

3.  b-broken.js 내부에서 require('a-broken.js') 호출 (순환 발생!)
    └─> b-broken.js의 const a 변수는 0xA1 객체를 참조합니다.
    ⚠️ 주요 문제: 0xA1은 이때 빈 객체입니다.

4.  a-broken.js가 로딩 완료 단계에서
    module.exports = {...}를 실행하며 0xA2로 주소를 덮어씁니다.

🎯 결과: 에러 발생 (참조 단절) ❌

b-broken.js 내부의 a 변수는 여전히 0xA1을 가리킵니다.
하지만 0xA1은 a-broken.js가 새로운 0xA2 객체를 만들고 버려버린 빈 껍데기입니다.

┌─────────────────────┬──────────────┬──────────────────────────┐
│ 변수 │ 참조 주소 │ 상태 │
├─────────────────────┼──────────────┼──────────────────────────┤
│ b.js 내부의 const a │ 0xA1 │ 빈 객체 (함수 없음) │
│ a.js의 최종 Exports │ 0xA2 │ 완성된 객체 (함수 있음) │
└─────────────────────┴──────────────┴──────────────────────────┘

따라서 b.js가 a.functionFromA()를 호출하면
"함수가 없는 빈 객체(0xA1)에 접근"했기 때문에 에러가 발생합니다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💥 결론: 에러가 나는 이유
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

에러는 오직 module.exports = {...} (재할당) 때문입니다.

순환 참조가 발생하면 Node.js는 "현재까지의 module.exports 객체"를 돌려줍니다.

✅ exports.xxx 방식:
→ 그 객체에 계속 내용을 채웁니다.
→ 같은 객체를 계속 사용하므로 참조가 유지됩니다.

❌ module.exports = {...} 방식:
→ 그 객체를 버리고 새 객체를 만들어버립니다.
→ 이미 참조를 가져간 다른 모듈은 버려진 옛날 객체만 보게 됩니다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
